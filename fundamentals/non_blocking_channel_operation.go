package main

import "fmt"

// selectを用いたノンブロッキングチャネル操作→何かしらで役に立つはず！

func main() {
	messages := make(chan string)
	signals := make(chan bool)

	// messagesチャネルからの受信を試みます。しかし、チャネルにはまだ何も送信されていないので、defaultケースが実行されて「no message received」と表示されます。
	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	default:
		fmt.Println("no message received")
	}

	// 非バッファードチャネルの送受信には複数のゴルーチンが必要。逆にバッファードチャネルであれば同一ルーチン内でチャネルを介したデータの送受信が可能(おそらく利用されることはないと思いますが)
	// よって下のselectは受信側の受信可能状態のルーチンが存在しないのでdefaultが実行される→参照：l:37~
	msg := "hi"
	select {
	case messages <- msg:
		fmt.Println("sent message", msg)
	default:
		fmt.Println("no message sent")
	}

	select {
	case msg := <-messages:
		fmt.Println("received message", msg)
	case sig := <-signals:
		fmt.Println("received signal", sig)
	default:
		fmt.Println("no activity")
	}
}

// 提供されたコードのこの部分において、defaultケースが実行される理由は、messages チャネルへの送信操作がブロッキングされるためです。messages チャネルは、バッファなし（非バッファード）チャネルとして作成されています。バッファなしチャネルは、送信側と受信側が同時に準備ができていない限り、直ちにデータの送受信が行えません。つまり、値をチャネルに送信しようとする操作は、その値を受け取る準備ができている受信側が存在するまでブロックされます。

// このコードの段階では、messages チャネルに値を送信しようとしていますが、このチャネルから値を受信しようとするゴルーチンまたは操作が存在しません。したがって、messages <- msg の操作は直ちに完了することができず、select ステートメントは default ケースを実行します。default ケースは、他のどのケースも即時に実行可能でない場合に実行されるため、この場合、「no message sent」と表示されます。

// バッファなしチャネルの性質上、送信操作が成功するためには、受信側が同時に受信を試みている必要があります。しかし、この例では受信側が存在しないため、送信試みは即時には成功せず、default ケースが選択されるのです。

// はい、その通りです。非バッファード（バッファなし）チャネルの送受信操作は、対応する受信側または送信側が準備ができるまでブロックされるため、通常、複数のゴルーチン間での同期やデータのやり取りに使用されます。これは、チャネルを介した通信が同時に発生する必要があることを意味します。一方で、バッファードチャネルは、指定された容量までデータを格納できるため、送信側がバッファにデータを追加するとすぐに実行を続けることができ、受信側は後でそのデータを取り出すことができます。

// バッファードチャネルを使用すると、同一のゴルーチン内でチャネルを介してデータを送受信することが技術的には可能になります。これは、バッファが満たされていない限り、送信操作がブロックされず、受信操作がバッファからデータを取得できるためです。ただし、このような使い方は一般的ではありませんし、Goの並行処理のパターンでは推奨されていないかもしれません。なぜなら、バッファードチャネルの主な用途は、非同期的なデータの送受信や、異なるゴルーチン間での作業のペーシング（流量制御）など、より複雑な並行処理のパターンにあります。

// 例えば、バッファサイズが1のバッファードチャネルを作成すると、同一ゴルーチン内であっても、チャネルに1つのメッセージを送信し、その後で受信することが可能です。このような操作が有用となる特定のシナリオは限られていますが、例えば短期間の値のキューイングや、特定の条件下での値の一時的な保持などが考えられます。
